#哈希表&散列表
2015/6/7 17:17:19 

一开始看书的时候还以为哈希表和散列表是两回事，原来指的都是同一种数据结构 —— Hashing。

这是一种**存储方法**，也是一种**查找方法**。Hashing在存储位置和关键字之间建立一种关系，使得关键字与存储结构中唯一的存储位置对应起来，我们称这个关系为哈希函数或散列函数，存储位置为关键字通过哈希函数计算出来的哈希地址。

建立哈希表的第一步是构造「哈希函数」，原则是尽可能地使任意一组关键字的哈希地址均匀地分布在整个地址空间中，以便减少冲突发生的可能性。

##1. 哈希函数的构造方法
1. 直接定址法
2. 平方取中法
3. 数字分析法
4. 除留余数法
5. 随机数法
6. 折叠法

其中最常用的构造方法是「除留余数法」：取关键字被某个不大于散列表表长m的数p除后所得到的余数作为散列地址，即H(key) = key%p, p<=m。通常选p为不大于散列表容量的最大素数（避免冲突）。

通常，关键字是字符串：

	Index Hash(const char *Key, int TableSize)
	{
		unsigned int HashVal = 0;
		
		while(*Key != "\0")
			HashVal = (HashVal << 5) + *Key++;
		
		return HashVal % TableSize;
	}

关键字是整数：

	Index Hash(const int *Key, int TableSize)
	{
		return *Key % TableSize;
	}


##2. 处理冲突的方法

###1.开放定址法

当冲突发生时，沿着「探查序列」逐个单元寻找可以存放记录的空闲单元。

形成探查序列的方法，假设散列表长度为m，节点个数为n：

####(1). 线性探查法

将散列表看作以环形表，当地址d出现冲突时，以此探查环形表内除地址d外的其他地址单元，找到一个空闲单元，存放关键字。（易发生“堆积”现象）

####(2) . 二次探查法

发生冲突时，将同义关键字来回散列在第一个地址d = H(key) 的两端，探查序列为1^2,-1^2,2^2,-2^2,...等。（不容易探查整个散列表）

###2.分离链接法（拉链法）

将所有关键字为同义词的节点链接在同一个单链表中。散列表定义为一个m个头指针组成的数组a[m],凡是散列地址为i的节点，均插入到以a[i]为头指针的单链表中。